using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Text; 

public class CardCreatorWindow : EditorWindow
{
    // ... (前半の変数は変更なし) ...
    CardData editTarget; 

    string cardId = "";
    string cardName = "New Card";
    string englishName = ""; 
    CardType cardType = CardType.UNIT;
    JobType cardJob = JobType.NEUTRAL;
    Rarity rarity = Rarity.COMMON;

    int cost = 1;
    int attack = 1;
    int health = 1;
    int maxInDeck = 2; // デフォルト2枚
    int duration = 3; 

    string description = "";
    Sprite cardIcon;

    List<CardAbility> abilities = new List<CardAbility>();
    Vector2 scrollPos;
    bool autoGenerateDescription = true;

    Texture2D rawImportImage; 
    bool removeWhiteBackground = true; 
    float whiteThreshold = 0.1f; 
    CropRatio cropRatio = CropRatio.Square_1x1; 

    public enum CropRatio { Square_1x1, Portrait_3x4, Landscape_4x3, Original }

    [MenuItem("Hakoniwa/Open Card Creator")]
    public static void ShowWindow()
    {
        GetWindow<CardCreatorWindow>("Card Creator");
    }

    void OnGUI()
    {
        // ... (GUI描画処理は変更なし) ...
        GUILayout.Label("カード作成・編集ツール", EditorStyles.boldLabel);
        scrollPos = EditorGUILayout.BeginScrollView(scrollPos);

        DrawLoadSection();

        EditorGUI.BeginChangeCheck(); 

        DrawBasicInfoSection();
        DrawImageProcessingSection(); 
        DrawParameterSection();
        DrawAbilitySection();
        DrawDetailSection();
        
        DrawSaveSection();

        EditorGUILayout.EndScrollView();
    }

    // ... (各Drawセクション、画像加工、保存ロジックなどは変更なし) ...
    // ... DrawLoadSection, DrawBasicInfoSection, DrawImageProcessingSection ...
    // ... DrawParameterSection, DrawAbilitySection, DrawDetailSection, DrawSaveSection ...
    // ... ResetInputFields, ProcessAndSaveImage, LoadCardData, SaveCardData, CopyImagePrompt ...

    void DrawLoadSection()
    {
        EditorGUILayout.Space();
        EditorGUILayout.LabelField("▼ 編集モード（既存カードを読み込む）", EditorStyles.boldLabel);
        EditorGUILayout.BeginVertical(GUI.skin.box);
        EditorGUILayout.BeginHorizontal();
        editTarget = (CardData)EditorGUILayout.ObjectField("編集対象", editTarget, typeof(CardData), false);
        GUI.backgroundColor = Color.yellow;
        if (GUILayout.Button("読込", GUILayout.Width(60))) LoadCardData();
        GUI.backgroundColor = Color.white;
        EditorGUILayout.EndHorizontal();
        if (editTarget != null) EditorGUILayout.HelpBox($"編集中: {editTarget.name}", MessageType.Info);
        else EditorGUILayout.HelpBox("新規作成モード", MessageType.None);
        EditorGUILayout.EndVertical();
    }

    void DrawBasicInfoSection()
    {
        EditorGUILayout.Space();
        GUILayout.Label("基本ステータス", EditorStyles.label);
        cardName = EditorGUILayout.TextField("Card Name (JP)", cardName);
        englishName = EditorGUILayout.TextField("English Name (AI用)", englishName); 
        EditorGUILayout.BeginHorizontal();
        cardId = EditorGUILayout.TextField("ID (File Name)", cardId);
        if (GUILayout.Button("Auto ID", GUILayout.Width(80))) GenerateAutoId();
        EditorGUILayout.EndHorizontal();
        cardType = (CardType)EditorGUILayout.EnumPopup("Type", cardType);
        cardJob = (JobType)EditorGUILayout.EnumPopup("Job", cardJob);
        rarity = (Rarity)EditorGUILayout.EnumPopup("Rarity", rarity);
    }

    void DrawImageProcessingSection()
    {
        EditorGUILayout.Space();
        GUILayout.Label("画像スタジオ (生成 & 加工)", EditorStyles.boldLabel);
        EditorGUILayout.BeginVertical(GUI.skin.box);
        EditorGUILayout.BeginHorizontal();
        EditorGUILayout.LabelField("1. 生成:", GUILayout.Width(50));
        if (GUILayout.Button("プロンプトをコピー", GUILayout.Height(20))) CopyImagePrompt();
        EditorGUILayout.EndHorizontal();
        EditorGUILayout.Space(5);
        EditorGUILayout.LabelField("2. 加工・取り込み:", GUILayout.Width(100));
        Event evt = Event.current;
        Rect dropArea = GUILayoutUtility.GetRect(0.0f, 60.0f, GUILayout.ExpandWidth(true));
        GUIStyle boxStyle = new GUIStyle(GUI.skin.box);
        boxStyle.alignment = TextAnchor.MiddleCenter;
        boxStyle.fontSize = 12;
        boxStyle.normal.textColor = Color.white;
        string boxText = (rawImportImage == null) ? "【ここに画像をドラッグ＆ドロップ】\n(ダウンロードフォルダから直接OK！)" : "画像セット済み (クリックで変更可)";
        GUI.Box(dropArea, boxText, boxStyle);
        switch (evt.type)
        {
            case EventType.DragUpdated:
            case EventType.DragPerform:
                if (!dropArea.Contains(evt.mousePosition)) break;
                DragAndDrop.visualMode = DragAndDropVisualMode.Copy;
                if (evt.type == EventType.DragPerform)
                {
                    DragAndDrop.AcceptDrag();
                    if (DragAndDrop.paths.Length > 0)
                    {
                        string path = DragAndDrop.paths[0];
                        if (System.IO.File.Exists(path) && (path.EndsWith(".png") || path.EndsWith(".jpg") || path.EndsWith(".jpeg") || path.EndsWith(".webp")))
                        {
                            byte[] fileData = System.IO.File.ReadAllBytes(path);
                            rawImportImage = new Texture2D(2, 2);
                            rawImportImage.LoadImage(fileData);
                        }
                    }
                    else if (DragAndDrop.objectReferences.Length > 0)
                    {
                        foreach (Object obj in DragAndDrop.objectReferences) { if (obj is Texture2D) { rawImportImage = (Texture2D)obj; break; } }
                    }
                }
                Event.current.Use();
                break;
        }
        rawImportImage = (Texture2D)EditorGUILayout.ObjectField("現在の画像", rawImportImage, typeof(Texture2D), false);
        if (rawImportImage != null)
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            GUILayout.Label("加工設定", EditorStyles.miniBoldLabel);
            cropRatio = (CropRatio)EditorGUILayout.EnumPopup("切り抜き比率", cropRatio);
            removeWhiteBackground = EditorGUILayout.Toggle("白背景を透明化", removeWhiteBackground);
            if (removeWhiteBackground) whiteThreshold = EditorGUILayout.Slider("白の許容範囲", whiteThreshold, 0f, 0.5f);
            EditorGUILayout.Space(5);
            GUI.backgroundColor = new Color(0.7f, 1f, 0.7f);
            if (GUILayout.Button("加工してアイコンに設定 (Process & Set)", GUILayout.Height(30))) ProcessAndSaveImage();
            GUI.backgroundColor = Color.white;
            EditorGUILayout.EndVertical();
        }
        EditorGUILayout.EndVertical();
    }

    void DrawParameterSection()
    {
        EditorGUILayout.Space();
        GUILayout.Label("数値パラメータ", EditorStyles.label);
        EditorGUILayout.BeginHorizontal();
        cost = EditorGUILayout.IntField("Cost", cost);
        maxInDeck = EditorGUILayout.IntField("Max In Deck", maxInDeck);
        EditorGUILayout.EndHorizontal();
        if (cardType == CardType.UNIT)
        {
            EditorGUILayout.BeginHorizontal();
            attack = EditorGUILayout.IntField("Attack", attack);
            health = EditorGUILayout.IntField("Health", health);
            EditorGUILayout.EndHorizontal();
        }
        else if (cardType == CardType.BUILD)
        {
            duration = EditorGUILayout.IntField("Duration (Turn)", duration);
        }
    }

    void DrawAbilitySection()
    {
        EditorGUILayout.Space();
        GUILayout.Label($"能力リスト ({abilities.Count})", EditorStyles.boldLabel);
        for (int i = 0; i < abilities.Count; i++)
        {
            EditorGUILayout.BeginVertical(GUI.skin.box);
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label($"Ability {i + 1}");
            if (GUILayout.Button("X", GUILayout.Width(20))) { abilities.RemoveAt(i); break; }
            EditorGUILayout.EndHorizontal();
            abilities[i].trigger = (EffectTrigger)EditorGUILayout.EnumPopup("Trigger", abilities[i].trigger);
            if (abilities[i].trigger != EffectTrigger.PASSIVE)
                abilities[i].target = (EffectTarget)EditorGUILayout.EnumPopup("Target", abilities[i].target);
            abilities[i].effect = (EffectType)EditorGUILayout.EnumPopup("Effect", abilities[i].effect);
            abilities[i].value = EditorGUILayout.IntField("Value", abilities[i].value);
            EditorGUILayout.EndVertical();
        }
        if (GUILayout.Button("+ 能力を追加")) abilities.Add(new CardAbility());
    }

    void DrawDetailSection()
    {
        EditorGUILayout.Space();
        GUILayout.Label("詳細・画像", EditorStyles.label);
        autoGenerateDescription = EditorGUILayout.Toggle("説明文を自動生成", autoGenerateDescription);
        if (EditorGUI.EndChangeCheck() && autoGenerateDescription) GenerateDescription();
        description = EditorGUILayout.TextArea(description, GUILayout.Height(50));
        cardIcon = (Sprite)EditorGUILayout.ObjectField("Icon (Final)", cardIcon, typeof(Sprite), false);
    }

    void DrawSaveSection()
    {
        EditorGUILayout.Space(20);
        EditorGUILayout.BeginHorizontal();
        GUI.backgroundColor = new Color(0.8f, 0.8f, 0.8f);
        if (GUILayout.Button("リセット (Clear)", GUILayout.Height(40), GUILayout.Width(100)))
        {
            if (EditorUtility.DisplayDialog("リセット確認", "入力内容を全てクリアして新規作成状態にしますか？", "OK", "キャンセル")) ResetInputFields();
        }
        string buttonLabel = (editTarget != null) ? "上書き保存 (Save)" : "新規作成 (Create)";
        GUI.backgroundColor = (editTarget != null) ? new Color(1f, 0.6f, 0.6f) : Color.cyan;
        if (GUILayout.Button(buttonLabel, GUILayout.Height(40))) SaveCardData();
        EditorGUILayout.EndHorizontal();
        GUI.backgroundColor = Color.white;
        if (editTarget != null)
        {
            if (GUILayout.Button("編集モードを終了して新規作成へ")) ResetInputFields();
        }
    }

    void ResetInputFields()
    {
        editTarget = null; cardId = ""; cardName = "New Card"; englishName = "";
        cardType = CardType.UNIT; cardJob = JobType.NEUTRAL; rarity = Rarity.COMMON;
        cost = 1; attack = 1; health = 1; maxInDeck = 2; duration = 3; 
        description = ""; cardIcon = null; abilities.Clear(); rawImportImage = null; 
        GUI.FocusControl(null); Debug.Log("入力フィールドをリセットしました。");
    }

    void ProcessAndSaveImage()
    {
        if (rawImportImage == null) return;
        if (string.IsNullOrEmpty(cardId)) { Debug.LogError("先にIDを決めてください（ファイル名に使います）"); return; }
        Texture2D readableTex = rawImportImage;
        string rawPath = AssetDatabase.GetAssetPath(rawImportImage);
        if (!string.IsNullOrEmpty(rawPath)) { byte[] fileData = File.ReadAllBytes(rawPath); readableTex = new Texture2D(2, 2); readableTex.LoadImage(fileData); }
        int width = readableTex.width; int height = readableTex.height; int cropSize = Mathf.Min(width, height);
        int targetW = cropSize; int targetH = cropSize;
        if (cropRatio == CropRatio.Portrait_3x4) { targetW = (int)(targetH * 0.75f); } else if (cropRatio == CropRatio.Landscape_4x3) { targetH = (int)(targetW * 0.75f); } else if (cropRatio == CropRatio.Original) { targetW = width; targetH = height; }
        int startX = (width - targetW) / 2; int startY = (height - targetH) / 2;
        Color[] pixels = readableTex.GetPixels(startX, startY, targetW, targetH);
        if (removeWhiteBackground) { for (int i = 0; i < pixels.Length; i++) { Color c = pixels[i]; if (c.r > 1f - whiteThreshold && c.g > 1f - whiteThreshold && c.b > 1f - whiteThreshold) { pixels[i] = new Color(0, 0, 0, 0); } } }
        Texture2D finalTex = new Texture2D(targetW, targetH); finalTex.SetPixels(pixels); finalTex.Apply();
        byte[] pngBytes = finalTex.EncodeToPNG();
        string folderPath = "Assets/Resources/CardIcons";
        if (!Directory.Exists(folderPath)) Directory.CreateDirectory(folderPath);
        string savePath = $"{folderPath}/{cardId}_icon.png";
        File.WriteAllBytes(savePath, pngBytes);
        AssetDatabase.Refresh();
        TextureImporter importer = AssetImporter.GetAtPath(savePath) as TextureImporter;
        if (importer != null) { importer.textureType = TextureImporterType.Sprite; importer.alphaIsTransparency = true; importer.SaveAndReimport(); }
        cardIcon = AssetDatabase.LoadAssetAtPath<Sprite>(savePath);
        Debug.Log($"画像を加工して保存しました: {savePath}");
        if (string.IsNullOrEmpty(rawPath)) DestroyImmediate(readableTex);
        rawImportImage = null; 
    }

    void LoadCardData()
    {
        if (editTarget == null) return;
        cardId = editTarget.id; if (string.IsNullOrEmpty(cardId)) cardId = editTarget.name;
        cardName = editTarget.cardName; cardType = editTarget.type; cardJob = editTarget.job; rarity = editTarget.rarity;
        cost = editTarget.cost; attack = editTarget.attack; health = editTarget.health; maxInDeck = editTarget.maxInDeck; duration = editTarget.duration;
        description = editTarget.description; cardIcon = editTarget.cardIcon;
        abilities.Clear();
        if (editTarget.abilities != null) foreach (var a in editTarget.abilities) abilities.Add(new CardAbility{trigger=a.trigger,target=a.target,effect=a.effect,value=a.value});
        Debug.Log($"{editTarget.name} を読み込みました。"); GUI.FocusControl(null); 
    }

    void SaveCardData()
    {
        if (string.IsNullOrEmpty(cardId)) { Debug.LogError("IDを入力してください！"); return; }
        string folderPath = "Assets/Resources/CardsData";
        if (!Directory.Exists(folderPath)) Directory.CreateDirectory(folderPath);
        CardData dataToSave = null; string newPath = $"{folderPath}/{cardId}.asset";
        if (editTarget != null) { string currentPath = AssetDatabase.GetAssetPath(editTarget); Undo.RecordObject(editTarget, "Update Card Data"); dataToSave = editTarget; if (currentPath != newPath) AssetDatabase.RenameAsset(currentPath, cardId); }
        else { if (AssetDatabase.LoadAssetAtPath<CardData>(newPath) != null) { if (!EditorUtility.DisplayDialog("上書き確認", $"'{cardId}' は既に存在します。", "上書き", "キャンセル")) return; } dataToSave = ScriptableObject.CreateInstance<CardData>(); AssetDatabase.CreateAsset(dataToSave, newPath); }
        dataToSave.id = cardId; dataToSave.cardName = cardName; dataToSave.type = cardType; dataToSave.job = cardJob;
        dataToSave.rarity = rarity; dataToSave.cost = cost; dataToSave.attack = attack; dataToSave.health = health;
        dataToSave.maxInDeck = maxInDeck; dataToSave.duration = duration; dataToSave.description = description;
        dataToSave.cardIcon = cardIcon; dataToSave.abilities = new List<CardAbility>(abilities);
        EditorUtility.SetDirty(dataToSave); AssetDatabase.SaveAssets(); AssetDatabase.Refresh();
        Debug.Log(editTarget != null ? $"カードを更新しました: {cardId}" : $"カードを作成しました: {cardId}");
        editTarget = dataToSave; Selection.activeObject = dataToSave;
    }

    void CopyImagePrompt()
    {
        string baseStyle = "pixel art, 8-bit style, single isolated game asset sprite, one miniature board game figure. Facing Right. IMPORTANT: NO base, NO pedestal. The figure stands directly on the white background. Consistent toy-like scale, cute but detailed, high contrast, clean pixel edges, fill the frame, tight crop, minimal margins, slight empty space in bottom right corner.";
        string subjectName = string.IsNullOrEmpty(englishName) ? cardName : englishName; 
        string jobStr = cardJob.ToString().ToLower(); 
        string typeStr = "";
        switch (cardType) { case CardType.UNIT: typeStr = $"single fantasy {jobStr} character unit, solo"; break; case CardType.SPELL: typeStr = $"single magic effect icon, one spell object, isolated fantasy item related to {jobStr}"; break; case CardType.BUILD: typeStr = $"single miniature building, one structure, isolated fantasy construction related to {jobStr}, isometric view"; break; }
        string finalPrompt = $"{subjectName}, {typeStr}. {baseStyle}";
        GUIUtility.systemCopyBuffer = finalPrompt;
        ShowNotification(new GUIContent("Prompt Copied!"));
        Debug.Log($"Copied: {finalPrompt}");
    }

    void GenerateDescription()
    {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < abilities.Count; i++)
        {
            var curr = abilities[i]; var prev = (i > 0) ? abilities[i - 1] : null; var next = (i + 1 < abilities.Count) ? abilities[i + 1] : null;
            bool isTriggerStart = (prev == null) || (curr.trigger != prev.trigger);
            
            // パッシブ効果の処理
            if (curr.trigger == EffectTrigger.PASSIVE) { 
                if (isTriggerStart && sb.Length > 0) sb.Append("\n"); 
                
                // ★ここを修正：「魔導」と表示する
                if (curr.effect == EffectType.SPELL_DAMAGE_PLUS) {
                    sb.Append($"魔導+{curr.value}");
                } else {
                    sb.Append(GetPassiveName(curr.effect)); 
                }

                if (next != null && next.trigger == EffectTrigger.PASSIVE) sb.Append("、"); 
                continue; 
            }

            // トリガー名の表示
            if (isTriggerStart) { 
                if (sb.Length > 0) sb.Append("\n");
                
                // スペルカード以外なら「【スペル使用時】」を表示
                if (curr.trigger != EffectTrigger.SPELL_USE || cardType != CardType.SPELL) 
                {
                    sb.Append($"【{GetTriggerName(curr.trigger)}】");
                }
            }
            
            // ターゲットと効果の生成
            bool showTarget = false; 
            if (curr.target != EffectTarget.NONE) { 
                if (isTriggerStart) showTarget = true; 
                else if (prev != null && curr.target != prev.target) showTarget = true; 
            }
            if (showTarget) { 
                string noun = GetTargetNoun(curr.target); 
                string particle = GetParticleForEffect(curr.effect); 
                sb.Append($"{noun}{particle}"); 
            }
            bool isNextSameTrigger = (next != null) && (next.trigger == curr.trigger);
            if (isNextSameTrigger) { 
                sb.Append(GetContinuativeEffectText(curr.effect, curr.value)); 
                sb.Append("、"); 
            } else { 
                sb.Append(GetTerminalEffectText(curr.effect, curr.value)); 
                sb.Append("。"); 
            }
        }
        description = sb.ToString();
    }

    string GetTriggerName(EffectTrigger trigger) 
    { 
        switch (trigger) { 
            case EffectTrigger.ON_SUMMON: return "召喚時"; 
            case EffectTrigger.ON_TURN_END: return "ターン終了時"; 
            case EffectTrigger.ON_ATTACK: return "攻撃時"; 
            case EffectTrigger.ON_DEATH: return "死亡時"; 
            case EffectTrigger.ON_MOVE: return "移動時"; 
            case EffectTrigger.SPELL_USE: return "スペル使用時"; // ★追加
            default: return trigger.ToString(); 
        } 
    }
    string GetTargetNoun(EffectTarget target) 
    { 
        switch (target) 
        { 
            case EffectTarget.FRONT_ENEMY: return "正面の敵"; 
            case EffectTarget.ALL_ENEMIES: return "敵全体"; 
            case EffectTarget.RANDOM_ENEMY: return "ランダムな敵1体"; 
            case EffectTarget.ENEMY_LEADER: return "敵リーダー"; 
            case EffectTarget.ALL_ALLIES: return "味方全体"; 
            case EffectTarget.FRONT_ALLY: return "正面の味方"; 
            case EffectTarget.PLAYER_LEADER: return "味方リーダー"; 
            case EffectTarget.SELECT_ENEMY_UNIT: return "選択した敵"; 
            case EffectTarget.SELECT_ENEMY_LEADER: return "敵リーダー"; 
            case EffectTarget.SELECT_ANY_ENEMY: return "選択した敵"; 
            case EffectTarget.SELECT_UNDAMAGED_ENEMY: return "無傷の敵"; 
            case EffectTarget.SELF: return "自身"; 
            // ★追加
            case EffectTarget.SELECT_ALLY_UNIT: return "選択した味方";
            case EffectTarget.SELECT_ANY_UNIT: return "選択したユニット";
            case EffectTarget.RANDOM_ALLY: return "ランダムな味方1体";
            case EffectTarget.ALL_UNITS: return "全ユニット";
            default: return ""; 
        } 
    }
    
    // ★修正：DRAW_CARD を追加して「は」を返すように変更
    string GetParticleForEffect(EffectType effect)
    {
        switch (effect)
        {
            // 「〜を」回復する / 破壊する / 手札に戻す
            case EffectType.HEAL: 
            case EffectType.DESTROY:
            case EffectType.RETURN_TO_HAND:
            case EffectType.FORCE_MOVE:
                return "を";

            // 「〜の」マナ最大値 / 攻撃力 / 体力
            case EffectType.GAIN_MANA:
            case EffectType.BUFF_ATTACK:
            case EffectType.BUFF_HEALTH:
                return "の";

            // ★追加：「〜は」カードを引く
            case EffectType.DRAW_CARD:
                return "は";

            // 「〜に」ダメージ / 付与
            case EffectType.DAMAGE:
            case EffectType.TAUNT: 
            case EffectType.PIERCE:
            case EffectType.STEALTH:
            case EffectType.QUICK:
            case EffectType.HASTE:
                return "に";

            default: return "に";
        }
    }

    string GetTerminalEffectText(EffectType effect, int value) { switch (effect) { case EffectType.DAMAGE: return $"{value}ダメージを与える"; case EffectType.HEAL: return $"{value}回復する"; case EffectType.BUFF_ATTACK: return $"攻撃力を+{value}する"; case EffectType.BUFF_HEALTH: return $"体力を+{value}する"; case EffectType.GAIN_MANA: return $"マナ最大値を+{value}する"; case EffectType.DESTROY: return "破壊する"; case EffectType.DRAW_CARD: return $"カードを{value}枚引く"; case EffectType.FORCE_MOVE: return "手札に戻す"; case EffectType.RETURN_TO_HAND: return "手札に戻す"; case EffectType.TAUNT: return "守護を付与する"; case EffectType.STEALTH: return "隠密を付与する"; case EffectType.QUICK: return "疾風を付与する"; case EffectType.HASTE: return "速攻を付与する"; case EffectType.PIERCE: return "貫通を付与する"; default: return ""; } }
    string GetContinuativeEffectText(EffectType effect, int value) { switch (effect) { case EffectType.DAMAGE: return $"{value}ダメージを与え"; case EffectType.HEAL: return $"{value}回復し"; case EffectType.BUFF_ATTACK: return $"攻撃力を+{value}し"; case EffectType.BUFF_HEALTH: return $"体力を+{value}し"; case EffectType.GAIN_MANA: return $"マナ最大値を+{value}し"; case EffectType.DESTROY: return "破壊し"; case EffectType.DRAW_CARD: return $"カードを{value}枚引き"; case EffectType.FORCE_MOVE: return "手札に戻し"; case EffectType.RETURN_TO_HAND: return "手札に戻し"; case EffectType.TAUNT: return "守護を付与し"; case EffectType.STEALTH: return "隠密を付与し"; case EffectType.QUICK: return "疾風を付与し"; case EffectType.HASTE: return "速攻を付与し"; case EffectType.PIERCE: return "貫通を付与し"; default: return ""; } }
    string GetPassiveName(EffectType effect) 
    { 
        switch (effect) { 
            case EffectType.TAUNT: return "守護"; 
            case EffectType.STEALTH: return "隠密"; 
            case EffectType.QUICK: return "疾風"; 
            case EffectType.HASTE: return "速攻"; 
            case EffectType.PIERCE: return "貫通"; 
            case EffectType.SPELL_DAMAGE_PLUS: return "魔導"; // ★ここ
            default: return ""; 
        } 
    }
    void GenerateAutoId() { if (string.IsNullOrEmpty(cardName)) { Debug.LogWarning("カード名を入力"); return; } string prefix = cardJob.ToString().Substring(0, 1).ToUpper(); string folderPath = "Assets/Resources/CardsData"; if (!Directory.Exists(folderPath)) Directory.CreateDirectory(folderPath); string[] files = Directory.GetFiles(folderPath, "*.asset"); int maxNum = 0; foreach (string file in files) { string fileName = Path.GetFileNameWithoutExtension(file); if (fileName.StartsWith(prefix)) { int underscoreIndex = fileName.IndexOf('_'); if (underscoreIndex > 1) { string numPart = fileName.Substring(1, underscoreIndex - 1); if (int.TryParse(numPart, out int num)) { if (num > maxNum) maxNum = num; } } } } cardId = $"{prefix}{maxNum + 1:D3}_{cardName}"; GUI.FocusControl(null); Debug.Log($"自動生成ID: {cardId}"); }
}