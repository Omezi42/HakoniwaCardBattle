using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using System.IO;
using System.Text; 

public class CardCreatorWindow : EditorWindow
{
    // ... (変数は変更なし) ...
    string cardId = "";
    string cardName = "New Card";
    CardType cardType = CardType.UNIT;
    JobType cardJob = JobType.NEUTRAL;
    Rarity rarity = Rarity.COMMON;

    int cost = 1;
    int attack = 1;
    int health = 1;
    int maxInDeck = 3;
    int duration = 3; 

    string description = "";
    Sprite cardIcon;

    List<CardAbility> abilities = new List<CardAbility>();
    Vector2 scrollPos;
    bool autoGenerateDescription = true;

    [MenuItem("Hakoniwa/Open Card Creator")]
    public static void ShowWindow()
    {
        GetWindow<CardCreatorWindow>("Card Creator");
    }

    void OnGUI()
    {
        // ... (GUI描画処理は変更なし) ...
        GUILayout.Label("新規カード作成ツール", EditorStyles.boldLabel);
        scrollPos = EditorGUILayout.BeginScrollView(scrollPos);

        EditorGUI.BeginChangeCheck(); 

        EditorGUILayout.Space();
        GUILayout.Label("基本ステータス", EditorStyles.label);
        
        cardName = EditorGUILayout.TextField("Card Name", cardName);
        
        EditorGUILayout.BeginHorizontal();
        cardId = EditorGUILayout.TextField("ID (File Name)", cardId);
        GUI.backgroundColor = Color.yellow;
        if (GUILayout.Button("Auto ID", GUILayout.Width(80))) GenerateAutoId();
        GUI.backgroundColor = Color.white;
        EditorGUILayout.EndHorizontal();

        cardType = (CardType)EditorGUILayout.EnumPopup("Type", cardType);
        cardJob = (JobType)EditorGUILayout.EnumPopup("Job", cardJob);
        rarity = (Rarity)EditorGUILayout.EnumPopup("Rarity", rarity);

        EditorGUILayout.Space();
        GUILayout.Label("数値パラメータ", EditorStyles.label);
        
        EditorGUILayout.BeginHorizontal();
        cost = EditorGUILayout.IntField("Cost", cost);
        maxInDeck = EditorGUILayout.IntField("Max In Deck", maxInDeck);
        EditorGUILayout.EndHorizontal();

        if (cardType == CardType.UNIT)
        {
            EditorGUILayout.BeginHorizontal();
            attack = EditorGUILayout.IntField("Attack", attack);
            health = EditorGUILayout.IntField("Health", health);
            EditorGUILayout.EndHorizontal();
        }
        else if (cardType == CardType.BUILD)
        {
            duration = EditorGUILayout.IntField("Duration (Turn)", duration);
        }

        EditorGUILayout.Space();
        GUILayout.Label($"能力リスト ({abilities.Count})", EditorStyles.boldLabel);
        
        for (int i = 0; i < abilities.Count; i++)
        {
            EditorGUILayout.BeginVertical(GUI.skin.box);
            EditorGUILayout.BeginHorizontal();
            GUILayout.Label($"Ability {i + 1}");
            if (GUILayout.Button("X", GUILayout.Width(20))) { abilities.RemoveAt(i); break; }
            EditorGUILayout.EndHorizontal();

            abilities[i].trigger = (EffectTrigger)EditorGUILayout.EnumPopup("Trigger", abilities[i].trigger);
            if (abilities[i].trigger != EffectTrigger.PASSIVE)
            {
                abilities[i].target = (EffectTarget)EditorGUILayout.EnumPopup("Target", abilities[i].target);
            }
            abilities[i].effect = (EffectType)EditorGUILayout.EnumPopup("Effect", abilities[i].effect);
            abilities[i].value = EditorGUILayout.IntField("Value", abilities[i].value);
            EditorGUILayout.EndVertical();
        }

        if (GUILayout.Button("+ 能力を追加")) abilities.Add(new CardAbility());

        EditorGUILayout.Space();
        GUILayout.Label("詳細・画像", EditorStyles.label);

        autoGenerateDescription = EditorGUILayout.Toggle("説明文を自動生成", autoGenerateDescription);

        if (EditorGUI.EndChangeCheck() && autoGenerateDescription) GenerateDescription();

        description = EditorGUILayout.TextArea(description, GUILayout.Height(50));
        cardIcon = (Sprite)EditorGUILayout.ObjectField("Icon", cardIcon, typeof(Sprite), false);

        EditorGUILayout.Space(20);

        GUI.backgroundColor = Color.cyan;
        if (GUILayout.Button("カードを作成・保存", GUILayout.Height(40))) CreateCardAsset();
        GUI.backgroundColor = Color.white;

        EditorGUILayout.EndScrollView();
    }

    void GenerateDescription()
    {
        StringBuilder sb = new StringBuilder();

        for (int i = 0; i < abilities.Count; i++)
        {
            var curr = abilities[i];
            var prev = (i > 0) ? abilities[i - 1] : null;
            var next = (i + 1 < abilities.Count) ? abilities[i + 1] : null;

            bool isTriggerStart = (prev == null) || (curr.trigger != prev.trigger);
            
            if (curr.trigger == EffectTrigger.PASSIVE)
            {
                if (isTriggerStart && sb.Length > 0) sb.Append("\n");
                sb.Append(GetPassiveName(curr.effect));
                if (next != null && next.trigger == EffectTrigger.PASSIVE) sb.Append("、");
                continue;
            }

            if (isTriggerStart)
            {
                if (sb.Length > 0) sb.Append("\n");
                if (curr.trigger != EffectTrigger.SPELL_USE) sb.Append($"【{GetTriggerName(curr.trigger)}】");
            }

            bool showTarget = false;
            if (curr.target != EffectTarget.NONE)
            {
                if (isTriggerStart) showTarget = true;
                else if (prev != null && curr.target != prev.target) showTarget = true;
            }

            if (showTarget)
            {
                string noun = GetTargetNoun(curr.target);
                string particle = GetParticleForEffect(curr.effect);
                sb.Append($"{noun}{particle}");
            }

            bool isNextSameTrigger = (next != null) && (next.trigger == curr.trigger);

            if (isNextSameTrigger)
            {
                sb.Append(GetContinuativeEffectText(curr.effect, curr.value));
                sb.Append("、");
            }
            else
            {
                sb.Append(GetTerminalEffectText(curr.effect, curr.value));
                sb.Append("。");
            }
        }
        description = sb.ToString();
    }

    string GetTriggerName(EffectTrigger trigger)
    {
        switch (trigger)
        {
            case EffectTrigger.ON_SUMMON: return "召喚時";
            case EffectTrigger.ON_TURN_END: return "ターン終了時";
            case EffectTrigger.ON_ATTACK: return "攻撃時";
            case EffectTrigger.ON_DEATH: return "死亡時";
            default: return trigger.ToString();
        }
    }

    string GetTargetNoun(EffectTarget target)
    {
        switch (target)
        {
            case EffectTarget.FRONT_ENEMY: return "正面の敵";
            case EffectTarget.ALL_ENEMIES: return "敵全体";
            case EffectTarget.RANDOM_ENEMY: return "ランダムな敵1体";
            case EffectTarget.ENEMY_LEADER: return "敵リーダー";
            case EffectTarget.ALL_ALLIES: return "味方全体";
            case EffectTarget.FRONT_ALLY: return "正面の味方";
            case EffectTarget.PLAYER_LEADER: return "味方リーダー";
            case EffectTarget.SELECT_ENEMY_UNIT: return "選択した敵";
            case EffectTarget.SELECT_ENEMY_LEADER: return "敵リーダー";
            case EffectTarget.SELECT_ANY_ENEMY: return "選択した敵";
            case EffectTarget.SELECT_UNDAMAGED_ENEMY: return "無傷の敵";
            case EffectTarget.SELF: return "自身";
            default: return "";
        }
    }

    string GetParticleForEffect(EffectType effect)
    {
        switch (effect)
        {
            // 「〜を」回復する / 破壊する / 手札に戻す
            case EffectType.HEAL: 
            case EffectType.DESTROY:
            case EffectType.RETURN_TO_HAND:
            case EffectType.FORCE_MOVE:
                return "を";

            // ★修正：「〜の」マナ最大値 / 攻撃力 / 体力
            case EffectType.GAIN_MANA:
            case EffectType.BUFF_ATTACK:
            case EffectType.BUFF_HEALTH:
                return "の";

            // 「〜に」ダメージ / 付与
            case EffectType.DAMAGE:
            case EffectType.TAUNT: 
            case EffectType.PIERCE:
            case EffectType.STEALTH:
            case EffectType.QUICK:
            case EffectType.HASTE:
                return "に";

            default: return "に";
        }
    }

    string GetTerminalEffectText(EffectType effect, int value)
    {
        switch (effect)
        {
            case EffectType.DAMAGE: return $"{value}ダメージを与える";
            case EffectType.HEAL: return $"{value}回復する";
            case EffectType.BUFF_ATTACK: return $"攻撃力を+{value}する";
            case EffectType.BUFF_HEALTH: return $"体力を+{value}する";
            case EffectType.GAIN_MANA: return $"マナ最大値を+{value}する";
            case EffectType.DESTROY: return "破壊する";
            case EffectType.DRAW_CARD: return $"カードを{value}枚引く";
            case EffectType.FORCE_MOVE: return "手札に戻す"; 
            case EffectType.RETURN_TO_HAND: return "手札に戻す";
            
            case EffectType.TAUNT: return "守護を付与する";
            case EffectType.STEALTH: return "隠密を付与する";
            case EffectType.QUICK: return "疾風を付与する";
            case EffectType.HASTE: return "速攻を付与する";
            case EffectType.PIERCE: return "貫通を付与する";
            
            default: return "";
        }
    }

    string GetContinuativeEffectText(EffectType effect, int value)
    {
        switch (effect)
        {
            case EffectType.DAMAGE: return $"{value}ダメージを与え";
            case EffectType.HEAL: return $"{value}回復し";
            case EffectType.BUFF_ATTACK: return $"攻撃力を+{value}し";
            case EffectType.BUFF_HEALTH: return $"体力を+{value}し";
            case EffectType.GAIN_MANA: return $"マナ最大値を+{value}し";
            case EffectType.DESTROY: return "破壊し";
            case EffectType.DRAW_CARD: return $"カードを{value}枚引き";
            case EffectType.FORCE_MOVE: return "手札に戻し"; 
            case EffectType.RETURN_TO_HAND: return "手札に戻し";
            
            case EffectType.TAUNT: return "守護を付与し";
            case EffectType.STEALTH: return "隠密を付与し";
            case EffectType.QUICK: return "疾風を付与し";
            case EffectType.HASTE: return "速攻を付与し";
            case EffectType.PIERCE: return "貫通を付与し";
            
            default: return "";
        }
    }

    string GetPassiveName(EffectType effect)
    {
        switch (effect)
        {
            case EffectType.TAUNT: return "守護";
            case EffectType.STEALTH: return "隠密";
            case EffectType.QUICK: return "疾風";
            case EffectType.HASTE: return "速攻";
            case EffectType.PIERCE: return "貫通";
            default: return "";
        }
    }

    // ... (ID生成、保存処理はそのまま) ...
    void GenerateAutoId()
    {
        if (string.IsNullOrEmpty(cardName)) { Debug.LogWarning("カード名を入力してください"); return; }
        string prefix = cardJob.ToString().Substring(0, 1).ToUpper();
        string folderPath = "Assets/Resources/CardsData";
        if (!Directory.Exists(folderPath)) Directory.CreateDirectory(folderPath);

        string[] files = Directory.GetFiles(folderPath, "*.asset");
        int maxNum = 0;
        foreach (string file in files)
        {
            string fileName = Path.GetFileNameWithoutExtension(file);
            if (fileName.StartsWith(prefix))
            {
                int underscoreIndex = fileName.IndexOf('_');
                if (underscoreIndex > 1)
                {
                    string numPart = fileName.Substring(1, underscoreIndex - 1);
                    if (int.TryParse(numPart, out int num)) { if (num > maxNum) maxNum = num; }
                }
            }
        }
        cardId = $"{prefix}{maxNum + 1:D3}_{cardName}";
        GUI.FocusControl(null); 
        Debug.Log($"自動生成ID: {cardId}");
    }

    void CreateCardAsset()
    {
        if (string.IsNullOrEmpty(cardId)) { Debug.LogError("IDを入力してください！"); return; }
        string folderPath = "Assets/Resources/CardsData";
        if (!Directory.Exists(folderPath)) Directory.CreateDirectory(folderPath);

        CardData newCard = ScriptableObject.CreateInstance<CardData>();
        newCard.id = cardId;
        newCard.cardName = cardName;
        newCard.type = cardType;
        newCard.job = cardJob;
        newCard.rarity = rarity;
        newCard.cost = cost;
        newCard.attack = attack;
        newCard.health = health;
        newCard.maxInDeck = maxInDeck;
        newCard.duration = duration;
        newCard.description = description;
        newCard.cardIcon = cardIcon;
        newCard.abilities = new List<CardAbility>(abilities);

        string path = $"{folderPath}/{cardId}.asset";
        if (AssetDatabase.LoadAssetAtPath<CardData>(path) != null)
        {
            if (!EditorUtility.DisplayDialog("上書き確認", $"'{cardId}' は既に存在します。上書きしますか？", "上書き", "キャンセル")) return;
        }

        AssetDatabase.CreateAsset(newCard, path);
        AssetDatabase.SaveAssets();
        AssetDatabase.Refresh();
        Debug.Log($"カードを作成しました: {path}");
        Selection.activeObject = newCard;
    }
}